package initializer

import (
	"bufio"
	"fmt"
	"jiko21/gomi/git"
	"os"
	"os/exec"

	"github.com/AlecAivazis/survey/v2"
)

type Initializer struct {
	branches []string
}

var POST_MERGE_SHELL = `#! /bin/bash
gomi
`

var execCommand = exec.Command

func New() (Initializer, error) {
	branches, err := git.GetBranch()
	if err != nil {
		return Initializer{}, err
	}
	initializer := Initializer{branches}
	return initializer, nil
}

func (i *Initializer) Exec() error {
	if isGomiignoreExists() {
		shouldOverwrite := false
		prompt := &survey.Confirm{
			Message: "`.gomiignore` file already exists. Do you overwrite it?",
		}
		survey.AskOne(prompt, &shouldOverwrite)
		if !shouldOverwrite {
			return nil
		}
	}
	selectedBranches := []string{}
	prompt := &survey.MultiSelect{
		Message: "Chose branches to ignore:",
		Options: i.branches,
	}
	survey.AskOne(prompt, &selectedBranches)

	shouldAutoMerge := false
	autoMergePrompt := &survey.Confirm{
		Message: "Do you want to run `gomi` automatically after merging a branch?",
	}
	survey.AskOne(autoMergePrompt, &shouldAutoMerge)
	if shouldAutoMerge {
		err := writeAfterMergeHook()
		if err != nil {
			return err
		}
	}
	return writeGomiignoreFile(selectedBranches)
}

func writeGomiignoreFile(branches []string) error {
	f, err := os.Create(".gomiignore")
	if err != nil {
		return err
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	headText := "# generated by `gomi init`"
	fmt.Fprintln(w, headText)
	for _, branch := range branches {
		fmt.Fprintln(w, branch)
	}
	return w.Flush()
}

func writeAfterMergeHook() error {
	f, err := os.Create(".git/hooks/post-merge")
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.Write([]byte(POST_MERGE_SHELL))
	if err != nil {
		return err
	}
	_, err = execCommand("chmod", "a+x", ".git/hooks/post-merge").Output()
	if err != nil {
		return err
	}
	return nil
}

func isGomiignoreExists() bool {
	_, err := os.Stat(".gomiignore")
	return err == nil
}
